<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand-Controlled Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* Video hidden, used for processing */
        #input-video { display: none; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 10;
            width: 250px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        h1 { font-size: 1.2rem; margin: 0 0 15px 0; font-weight: 300; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; opacity: 0.8; }
        
        /* Shape Buttons */
        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.8rem;
        }
        button:hover, button.active { background: rgba(255, 255, 255, 0.3); border-color: white; }

        /* Color Picker */
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        /* Status Indicator */
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            pointer-events: none;
        }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Loading AI Models...</div>

    <div id="ui-container">
        <h1>Particle Control</h1>
        
        <div class="control-group">
            <label>Shape Template</label>
            <div class="shape-grid">
                <button onclick="setShape('heart')" class="active" id="btn-heart">Heart</button>
                <button onclick="setShape('saturn')" id="btn-saturn">Saturn</button>
                <button onclick="setShape('flower')" id="btn-flower">Flower</button>
                <button onclick="setShape('buddha')" id="btn-buddha">Buddha</button>
                <button onclick="setShape('fireworks')" id="btn-fireworks">Fireworks</button>
                <button onclick="setShape('sphere')" id="btn-sphere">Sphere</button>
            </div>
        </div>

        <div class="control-group">
            <label>Particle Color</label>
            <input type="color" id="colorPicker" value="#ff0055">
        </div>
    </div>

    <div id="status">Waiting for hands...</div>
    <video id="input-video"></video>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.05;
    
    // --- State ---
    let currentShape = 'heart';
    let targetPositions = [];
    let currentPositions = [];
    let particleGeometry;
    let particleMaterial;
    let particles;
    let scene, camera, renderer;
    let time = 0;
    
    // Hand State
    let handDistance = 1.0; // Expansion factor
    let handTension = 0.0;  // Jitter factor

    // --- Three.js Setup ---
    function initThree() {
        scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Initialize Particles
        particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initial random positions
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            positions[i] = (Math.random() - 0.5) * 10;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create a soft glowing texture for particles programmatically
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const texture = new THREE.CanvasTexture(canvas);

        particleMaterial = new THREE.PointsMaterial({
            color: 0xff0055,
            size: PARTICLE_SIZE,
            map: texture,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Initialize target positions based on default shape
        calculateShapePositions('heart');
        
        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            particleMaterial.color.set(e.target.value);
        });

        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Shape Mathematics ---
    function getPointOnHeart(t, p) {
        // Parametric Heart
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        let z = p * 10; // Thickness
        return new THREE.Vector3(x * 0.1, y * 0.1, z * 0.1);
    }

    function getPointOnSphere() {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 2;
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
    }

    function getPointOnSaturn() {
        // Mix of sphere and ring
        const isRing = Math.random() > 0.4;
        if(isRing) {
            const angle = Math.random() * Math.PI * 2;
            const r = 2.5 + Math.random() * 1.5;
            return new THREE.Vector3(Math.cos(angle)*r, (Math.random()-0.5)*0.1, Math.sin(angle)*r);
        } else {
            const vec = getPointOnSphere();
            vec.multiplyScalar(0.8); // Planet is smaller
            return vec;
        }
    }

    function getPointOnFlower(t) {
        // Rose curve 3D approximation
        const k = 4; // petals
        const r = Math.cos(k * t);
        const x = r * Math.cos(t) * 2;
        const y = r * Math.sin(t) * 2;
        const z = (Math.random() - 0.5) * 1.5 * r; // Depth based on radius
        return new THREE.Vector3(x, y, z);
    }

    function getPointOnBuddha() {
        // Abstract seated figure using geometric primitives
        const r = Math.random();
        let vec = new THREE.Vector3();
        
        if (r < 0.2) { 
            // Head
            vec = getPointOnSphere();
            vec.multiplyScalar(0.4);
            vec.y += 1.2; 
        } else if (r < 0.6) {
            // Torso (Cylinder-ish/Oval)
            vec = getPointOnSphere();
            vec.x *= 0.8; vec.z *= 0.7; vec.y *= 0.9;
            vec.y += 0.2;
        } else {
            // Legs (Crossed - simplified as a wide flattened torus/oval base)
            const angle = Math.random() * Math.PI * 2;
            const rad = 0.8 + Math.random() * 0.7;
            vec.x = Math.cos(angle) * rad;
            vec.z = Math.sin(angle) * rad;
            vec.y = (Math.random() - 0.5) * 0.5 - 0.8;
        }
        return vec;
    }

    function calculateShapePositions(type) {
        targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let vec = new THREE.Vector3();
            const idx = i * 3;

            if (type === 'heart') {
                vec = getPointOnHeart(Math.random() * Math.PI * 2, Math.random() - 0.5);
            } else if (type === 'sphere') {
                vec = getPointOnSphere();
            } else if (type === 'saturn') {
                vec = getPointOnSaturn();
                // Tilt saturn
                vec.applyAxisAngle(new THREE.Vector3(1,0,1).normalize(), 0.5);
            } else if (type === 'flower') {
                vec = getPointOnFlower(Math.random() * Math.PI * 2);
            } else if (type === 'buddha') {
                vec = getPointOnBuddha();
            } else if (type === 'fireworks') {
                // For fireworks, target is expanded sphere, but we will animate expansion
                vec = getPointOnSphere();
                vec.multiplyScalar(Math.random() * 3 + 1);
            }

            targetPositions[idx] = vec.x;
            targetPositions[idx+1] = vec.y;
            targetPositions[idx+2] = vec.z;
        }
    }

    // UI Handler
    window.setShape = function(shape) {
        currentShape = shape;
        
        // UI updates
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-'+shape).classList.add('active');
        
        calculateShapePositions(shape);
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        const positions = particles.geometry.attributes.position.array;
        
        // Calculate the center of the particle system (to rotate around)
        particles.rotation.y = time * 0.1;

        // Base Scale from hands (clamped)
        const targetScale = Math.max(0.2, Math.min(3.0, handDistance * 2)); // Map 0-1 to 0-3
        // Smoothly interpolate scale
        particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const px = i*3;
            const py = i*3+1;
            const pz = i*3+2;

            // Interpolate current pos to target pos
            // We use a simple lerp for morphing
            positions[px] += (targetPositions[px] - positions[px]) * 0.05;
            positions[py] += (targetPositions[py] - positions[py]) * 0.05;
            positions[pz] += (targetPositions[pz] - positions[pz]) * 0.05;

            // Add Tension (Jitter based on fist clench)
            // If handTension is high, add random noise
            if(handTension > 0.1) {
                const shake = handTension * 0.05;
                positions[px] += (Math.random()-0.5) * shake;
                positions[py] += (Math.random()-0.5) * shake;
                positions[pz] += (Math.random()-0.5) * shake;
            }

            // Optional: Slight organic movement
            if (currentShape === 'fireworks') {
                 // Fireworks logic: simple gravity fall
                 if (positions[py] > -3) targetPositions[py] -= 0.01;
            }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // --- MediaPipe Hand Tracking ---
    const videoElement = document.getElementById('input-video');
    const statusElement = document.getElementById('status');
    const loadingElement = document.getElementById('loading');

    function onResults(results) {
        loadingElement.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusElement.innerText = `Hands Detected: ${results.multiHandLandmarks.length}`;
            
            // Logic for 2 hands: Expansion/Scaling
            if (results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0][9]; // Middle finger knuckle
                const hand2 = results.multiHandLandmarks[1][9];
                
                // Calculate distance between hands (X/Y plane is enough for interaction)
                const dx = hand1.x - hand2.x;
                const dy = hand1.y - hand2.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Smoothly update global handDistance
                handDistance = handDistance * 0.9 + dist * 0.1;
            }

            // Logic for Tension (Fist detection)
            // Average tension of all detected hands
            let totalTension = 0;
            results.multiHandLandmarks.forEach(landmarks => {
                // Compare distance between Wrist(0) and Middle Finger Tip(12)
                const wrist = landmarks[0];
                const tip = landmarks[12];
                const dist = Math.sqrt(Math.pow(wrist.x - tip.x, 2) + Math.pow(wrist.y - tip.y, 2));
                
                // If dist is small -> Fist. If large -> Open palm.
                // dist varies roughly 0.1 (fist) to 0.4 (open) depending on camera distance
                // Let's invert it: Short distance = High Tension
                let tension = 0;
                if(dist < 0.15) tension = 1.0; // Clenched
                else if(dist > 0.3) tension = 0.0; // Open
                else tension = 1.0 - ((dist - 0.15) / 0.15); // Gradient
                
                totalTension += tension;
            });
            
            handTension = totalTension / results.multiHandLandmarks.length;

        } else {
            statusElement.innerText = "No hands detected - Show hands to control";
            // Slowly return to default scale if no hands
            handDistance = handDistance * 0.95 + 0.5 * 0.05;
            handTension = 0;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    // Start everything
    initThree();
    cameraUtils.start();

</script>
</body>
</html>